# W06 스터디
## Section 13

## 1. DOM을 업데이트하는 원리
> 어떻게 컴포넌트 함수들을 실행할지 (즉, 컴포넌트를 화면에 어떻게 렌더링되는지)

`React 가상 Dom 라이브러리`를 이용
> 이 `React Dom`이 React element들인 JSX코드를 Return 반환 -> JS 코드로 변환해서 HTML body에 둘 수 있도록(rendering) 해줘

> **가상 DOM의 과거 스냅샷(Snapshot) 과 현재 스냅샷(Snapshot) 차이를 비교해서, 변동사항이 있으면 실제 DOM에 적용**

**Component Tree**

![image](https://github.com/user-attachments/assets/da4e6fe5-3ba8-42c4-9257-e450e49e2b5c)

![image](https://github.com/user-attachments/assets/914b17e7-dc46-4566-8f33-c3f33e372d84)

트리 구조안에서 컴포넌트가 변경사항이 발생되면, `부모(상위) 컴포넌트`에게는 영향을 주지않고, 해당 컴포넌트의 `State`, `Props` 가 변경이 일어나면 `자식(하위) 컴포넌트`에는 영향을 전파 (리렌더링)

> React 개발 툴을 **Prifiler** 활용!
---

## 2. 불필요한 컴포넌트 업데이트를  방지

### 1) `React.memo()`

(컴포넌트 함수르 감싸서 사용)

`React.memo()`는 props 에 따라 컴포넌트를 렌더링시 다시 또 그릴것인지 판단하는 함수

- Props가 변화 되지 않은 등 컴포넌트가 업데이트 되지 않아도 되는 상황 에서 re-redering이 되는 불필요함을 막기 위해 쓰임 (성능 최적화에 가까움)

> `React.memo`는 오직 props 가 변경됐는지 아닌지만 계속 체크 --> But, 계속 Props 변화를 체크하는 것은 성능에 부담을 줄 수 있기에 남용 X

![image](https://github.com/user-attachments/assets/39787487-4036-44b7-9fbb-6c55bb61195c)

**주의: props 가 `함수형 타입`일 경우에는 리렌더링 될 때마다 새로운 메모리 주소에 할당되므로 계속 리렌더링이 발생됨**

### 2) `useCallBack` 훅

- 함수의 재생성을 방지하기 위해
  
- UseCallback 메모이제이션된 콜백 함수, 즉 `이미 생성된 함수를 반환`하는 리액트 훅을 사용.

- `useMemo` 는 특정 결과값을 재사용 할 때 사용하는 반면, `useCallback` 은 특정 함수를 새로 만들지 않고 재사용하고 싶을때 사용

- 즉 `함수 자체를 기억`
  
- 렌더링 될 때 함수 자체가 재시작 돼도 함수가 새로 만들어지지 않는다.

- 자식 컴포넌트에게 메서드를 전달할 때에는 useCallBack으로 감싸서 전달할 때마다 메서드가 새로 생성되지 않도록 한다.

- 이전 state 값을 계속 기억하기 있기 때문에 함수 안에서 사용하는 state 혹은 props 가 있다면 꼭, deps (의존성 배열)안에 포함시켜야 된다.

### 3) `useMemo()` 훅

(컴포넌트 함수 안에 있는 일반함수들을 감싸서 사용)

- `연산 비용이 큰 함수의 결과값을 메모이제이션(재사용) 하기위해 사용`

- `의존성 배열(deps)의 값이 변경되었을 때`만 해당 함수를 다시 실행
- [deps] 참조 값이 바뀐다면 ? 함수도 다시 재생성. 즉, 주소값이 바뀜
	
- 어떤 값을 리턴하는 어떤 함수에게 특정 값이 변화할 때만 리턴 연산을 수행할 것임을 명시해주고 싶을 때 사용
	
Ex) 
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);

위 코드의 경우 a, b 값이 변할 때만 useMemo의 첫번째 인자인 함수가 실행되어 재계산되고, 그렇지 않은 경우에는 메모이즈된 값을 리턴한다.

-> `useMemo()` 는 렌더되는 중에 계산 , `useEffect` 는 렌더링이 끝난 후에 수행

-> 따라서 **비동기(aSync) 작업은 useEffect 에서 처리하는게 적절**

---

## 3. Key 사용법

### 1) 컴포넌트 인스턴스별 state(상태) 관리

- State(상태)는 해당 컴포넌트 안에 속해 있다

- 만약 똑같은 컴포넌트 함수를 가지고 여러 컴포넌트 인스턴스를 구성하면, **모든 인스턴스는 `각자의 state(상태)`를 갖는다**

> `key` 는 state(상태)를 구체적인 컴포넌트 인스턴스에 매핑할 때 사용

### 2) 불필요한 재생성을 방지

- 또한 컴포넌트 리렌더링이 발생할 때, 이전 가상 DOM 스냅샷 에서는 각 컴포넌트 인스턴스의 `key` 값을 고유별로 가지고있으므로

> 변경점을 찾을때도 새로운 변경사항 부분을 key 로 구분해서 불필요한 재생성을 방지

### 3) 컴포넌트 초기화

- 특정 컴포넌트에 key 로 props를 전달하여 컴포넌트 렌더링 초기화를 구성했을 때, 해당 key값 변화가 일어났을 때 새로운 컴포넌트 초기화가 발생되게 동작 

---

## 4. State 스케줄링(Schedule) & 배치(Bach)

- useState()를 통해 전달한 state(상태)를 업데이트 하는데 있어,
  
- state를 업데이트 하는 함수에게 전달하는 방식을 사용을 하면
- 그 함수가 이전 state 스냅샷을 받고 새로운 state(상태) 스냅샷을 반환

![image](https://github.com/user-attachments/assets/5c11873b-4104-4b94-b923-ca519f68fda9)

같은 함수 내에 state 업데이트 함수가 여러개 있을 때, 배치된 대로 업데이트 한 state 결과를 반환


### Million.js 학습

